\subsection{Model Management}
As described in the challenges section, we had to redesign this service. The main
reason is the multiprocessing needs of the application that was unforeseeable for
us during the design phase. The complete changelog requires a completely new design
document but the following are the most important changes.

\subsubsection{Router}
\begin{itemize}
    \item 
    Split the Router class into two classes, CommonRoutes and WorkspaceRoutes.
    \newline
    \textbf{Reason:} API endpoints that need authentication are all under
    a specific workspace, so the split made it easier to handle the authentication
    of requests. We use an authentication middleware for all workspace routes. 
    \item
    Removed generatePredictionId method
    \newline
    \textbf{Reason:} We delegate this responsibility to the MongoDB client that
    generates a new ID for each document that is inserted into the database.
    \item
    Removed the trainers and predictors fields
    \newline
    \textbf{Reason:} Trainers map was planned to be used to track the progress.
    Since each trainer starts in a new process, this was not possible and we used
    the database for progress tracking instead. Predictors are in a new class
    PredictionManager described below.
\end{itemize}

\subsubsection{Request and Response Classes}
\begin{itemize}
    \item
    Renamed the data classes.
    \newline
    \textbf{Reason:} The classes now represent the actual content instead of the name
    of the API endpoint (i.e. TrainReq -> TrainingConfig)
    \item
    Seperate (sometimes duplicate) classes for domain models and API models
    \newline
    \textbf{Reason:} The first iteration of the service showed us that using the
    same models for both internal logic and API endpoints are problematic because
    of the possible changes to the endpoints. By seperating the classes, we had
    the flexibility to change endpoints/parameters without affecting the logic code,
    since the API models are converted to domain models.
    \item
    Added data validation for endpoints 
    \newline
    \textbf{Reason:} During the design, the data validation was missing. We have
    added the data validation for models with comprehensible error messages that
    frontend shows the end users.
\end{itemize}

\subsubsection{Database}
\begin{itemize}
    \item
    Added wrapper classes for database queries
    \newline
    \textbf{Reason:} At first we were calling the functions of PyMongo directly in
    the application code. We thought this was not a good idea as it was not possible
    to use a different database. With that in mind, we implemented several wrapper
    classes which implement database queries.
\end{itemize}

\subsubsection{Database Models}
\begin{itemize}
    \item
    Added (de)serialization methods for database models
    \newline
    \textbf{Reason:} We save large data in the database in binary form. 
    (bytes type). To prevent errors during the deserialization because of the
    unknown type of the binary objects, we added methods that complete
    the type information for each binary document to database model classes.
\end{itemize}

\subsubsection{Training}
\begin{itemize}
    \item
    Training a model is handled by a new process
    \newline
    \textbf{Reason:} The training of a model takes a notable amount of time,
    especially if there are a lot of samples. If the main process were to train
    the model, any requests during the training could only be handled after the
    training is finished. This was a terrible idea, so a new process is created
    to handle the training and the main thread is then able to handle other
    requests during the training.

    \item
    Added DataSetManager and TrainingManager classes
    \newline
    \textbf{Reason:} The Trainer class which we initially designed was a typical
    God object in which the training pipeline, all the training algorithms and
    the database queries are implemented. With seperation of concerns in mind, we
    decided to split this Trainer class in three classes: DataSetManager handles 
    the database queries, the Trainer class has all the algorithms implemented and
    the TrainingManager handles the training pipeline.
\end{itemize}

\subsubsection{Prediction}
\begin{itemize}
    \item
    Prediction is handled by a new process
    \newline
    \textbf{Reason:} This has the same motivation with handling the training with a
    new process: Being able to handle other requests while a prediction is under way.

    \item
    Added DataSetManager and PredictionManager classes
    \newline
    \textbf{Reason:} This also has the same reasoning with the training: The Predictor
    class we had was a typical God object. The DataSetManager handles the database
    queries, the Predictor class implements all the algorithms and the PredictionManager
    handles the prediction pipeline.
\end{itemize}
